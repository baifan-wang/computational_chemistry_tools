#!/usr/bin/env python3

"""
A script to auto process, plot and recluster the dlg file generated by Autodock.
require: numpy, matplotlib
"""
import os, sys, math
import numpy as np

__author__='Baifan Wang'

def dlg_loader(dlg):
    """load the dlg file and return the lines in dlg """
    try:
        with open(dlg) as f:
            lines = f.readlines()
    except:
        print('Could not open pdb file!')
        raise
    return lines

def dlg_parser(dlg):
    '''extract the coordiantes for each run and append to the coords;
                the cluster result and store in cluster_data;
                the rmsd, energy, for each run and store in rmsd_dict;
                the coordiantes of the lowest energy structure of each sluster and sotre in lowest_pdb;
                and the rms value of the dlg.'''
    name = os.path.split(dlg)[1][:-4]  #strip the '.dlg' form 'name.dlg'
    coords = {} #a dict to store the {run:[energy, Ki, [coordinate]]}, coordiante = coords[run][2]
    cluster_data = [] #cluster_rank, lowest_energy, #run, mean_energy, num_in_cluster
    rmsd_dict = {} #like this {cluster_rank:[['rank in cluster', 'run', 'energy', 'rmsd in cluster', 'rmsd to ref'],}
                    #run = rmsd_dict[cluster_rank][0][1]; energy = rmsd_dict[cluster_rank][0][2]
    lines = dlg_loader(dlg)
    i = 0
    while i < len(lines):
        if lines[i].startswith('DPF> rmstol'):         #line contain rms
            rms = lines[i].split()[2]
        if lines[i].startswith('DOCKED: USER    Run'): #biginning line for each run
            run = lines[i].split()[-1]                 #run start from 1
            coords[run] = []
            coords[run].append(float(lines[i+3].split()[8])) #Estimated Free Energy of Binding = lines[i+3]
            coords[run].append(lines[i+4].split()[7])        #Estimated Inhibition Constant, Ki line = lines[i+4]
            coords[run].append([])                           #a list to store coordiantes
            i = i+4                                          #to skip unnecessary lines.
        if lines[i].startswith('DOCKED: ATOM'):              #where coordinates are 
            coords[run][2].append(lines[i][8:63]+'\n')       #the coordiante will be coords[run][2]
        if lines[i].endswith('#\n'):                         #the CLUSTERING HISTOGRAM ends with sth like this '####\n'
            temp = lines[i].split()
            if temp[0].isnumeric():                          #the biginning of line should starts with number
                cluster_data.append([temp[i] for i in range(0,len(temp),2)]) # data are in 2, 4, 6, 8..column
        if lines[i].endswith('RANKING\n'):                   #RMSD TABLE ends with 'RANKING\n'
            temp = lines[i].split()
            if temp[0] not in rmsd_dict:                     #cluster not found in dict, creat a new one.
                rmsd_dict[temp[0]] = [temp[1:6]]
            else:
                rmsd_dict[temp[0]].append(temp[1:6])
        if lines[i].startswith('MODEL'):                     #break before the 'MODEl' line.
            break
        i += 1
    return coords, cluster_data, rmsd_dict, rms

def print_result(cluster_data):
    '''print the cluster_data'''
    print('#Cluster\tLowest energy\t#Run\tMean energy\tNumber in cluster\n')
    for i in cluster_data:
        for l in i:
            print(l, end = '\t')
        print('')

def write_result(cluster_data, output):
    '''write the cluster_data to output'''
    try:
        with open(output, 'w') as f:
            f.write('#Cluster\tLowest energy\t#Run\tMean energy\tNumber in cluster\n')
            for i in cluster_data:
                for l in i:
                    f.write(str(l)+'\t')
                f.write('\n')
    except:
        print('Could write file! Please check.')
        raise

def write_rmsd(rmsd_dict, output):
    '''write the rmsd_dict to output'''
    try:
        with open(output, 'w') as f:
            f.write('Rank\tSubrank\tRun\tBinding Energy\tCluster RMSD\tReference RMSD\n')
            for i in range(1, len(rmsd_dict)+1):
                for l in rmsd_dict[str(i)]:
                    f.write('\t'.join([str(i), '\t'.join([str(n) for n in l]), '\n']))
    except:
        print('Could write pdb file! Please check.')
        raise

def group_coordinate(coords, rmsd_dict, name, lowest=False):
    '''if lowest == False: group the coordinates of each run base on cluster 
        and write them to seperate file eg: aa_cluster_1.pdb.
        if Ture: only write the lowest energy structure in each cluster into a pdb file. eg: xxx_lowest.pdb'''
    if lowest == False:
        for cluster in rmsd_dict:
            n = 1
            with open(name+'_cluster_'+cluster+'.pdb', 'w') as pdb:
                for l in rmsd_dict[cluster]:
                    pdb.write('MODEL        '+str(n)+'\n')
                    for i in coords[l[1]][2]:
                        pdb.write(i)
                    pdb.write('TER\n')
                    pdb.write('ENDMDL\n')
                    n +=1
    elif lowest == True:
        with open(name+'_lowest.pdb', 'w') as pdb:
            for i in range(1, len(rmsd_dict)+1):
                c = str(i)
                run = rmsd_dict[c][0][1]
                pdb.write('MODEL        '+run+'\n')
                for i in coords[run][2]:
                    pdb.write(i)
                pdb.write('TER\n')
                pdb.write('ENDMDL\n')

def plot_nmuber_in_cluster(cluster_data, name, rms):
    '''make bar chart of the 'number in each cluster' vs 'lowest energy of each cluster'.'''
    try:
        import matplotlib.pyplot as plt
    except ImportError:
        print('Unabel to import matplotlib!')
        raise
    plt.style.use('ggplot') #using 'R' like style
    n_cluster = []          #number in cluster
    l_energy = []           #lowest energy
    for i in cluster_data:
        n_cluster.append(int(i[-1]))
        l_energy.append(float(i[1]))
    n_cluster = np.array(n_cluster)
    l_energy = np.array(l_energy)
    fig, ax = plt.subplots()
    bar_width = 0.05
    opacity = 0.4
    error_config = {'ecolor': '0.3'}
    rects1 = plt.bar(l_energy, n_cluster, bar_width, color = 'steelblue', edgecolor = 'k', linewidth = .5)
    plt.xlabel('Binding Energy', fontsize = 12)
    plt.ylabel('Number in Cluster', fontsize = 12)
    plt.title(name+': '+rms+' rms', fontsize = 12)
    plt.tight_layout()
    plt.show()
#    plt.savefig(name+'.png', dpi = 300, format = 'png',bbox_inches='tight')  #can also save fig.

def computeRMSD(refCoords, targetCoords):
    '''compute the overall root mean square distance (rmsd) between each pair of points.'''
    if refCoords is None:
        raise ValueError("no reference coordinates")
    if len(refCoords) != len(targetCoords):
        raise ValueError("input vector length mismatch")

    deltaVect = np.array(refCoords) - np.array(targetCoords)
    distSquaredVect = np.sum(np.transpose(deltaVect*deltaVect))
    distVect = np.sqrt(distSquaredVect)
    rmsd = math.sqrt(np.sum(distSquaredVect)/len(refCoords))
    return rmsd

def get_coord(coords, run):
    '''get coordinate of #run form coords, and return it as a numpy array.'''
    coor = []
    run = str(run)
    for i in coords[run][2]:
        coor.append([float(i) for i in i.split()[6:9]])
    coor = np.array(coor)
    return coor

def recluster(coords, rms):
    '''recluster the result based on the input rms. 
    The 1st reference will be the lowest energy conformation in the coords, the rmsd of all conformations
    with respect to reference will be computed, those rmsd values less than rms will be grouped into one cluster,
    and removed from coords.
    Then the reference will be the lowest energy conformation in the remain conformations and process continue 
    until all of the coords are clustered.
    It will generate new pdb, lowest energy pdb, rmsd_dict, cluster_data.'''
    energy = []          #a temporary list to store all of the energy in the coords.
    rmsd_dict = {}       #the new rmsd_dict
    cluster_data = []    
    for i in coords:
        energy.append([i, float(coords[i][0])])
    n = 1                            #record the cluster rank
    energy.sort(key=lambda x:x[1])   #sort the energy value form low->high
    while energy:
        ref = energy[0]              #[run, energy], ref is the lowest energy conformation
        rmsd_dict[str(n)]=[]
        m = 1                        #record the rank in cluster
        for i in range(len(energy)):
            rmsd = computeRMSD(get_coord(coords, ref[0]), get_coord(coords, energy[i][0]))
            if rmsd <= rms:
                rmsd_dict[str(n)].append([m, energy[i][0], energy[i][1], round(rmsd,3)])
                m += 1                             #record the rank in cluster
                energy[i] = None                   #mark the one has been put into a cluster 
        energy = [i for i in energy if i != None]  #and remove the one has been put into a cluster 
        n += 1
    for i in rmsd_dict:
        cluster_rank = i
        all_energy = [l[2] for l in rmsd_dict[i]]  #energy = rmsd_dict[cluster_rank][0][2]
        lowest_energy = min(all_energy)
        run = rmsd_dict[i][0][1]                   #run = rmsd_dict[cluster_rank][0][1]
        number_in_cluster = len(all_energy)
        mean_energy = round(sum(all_energy)/number_in_cluster,2)
        cluster_data.append([cluster_rank, lowest_energy, run, mean_energy, number_in_cluster])
    return rmsd_dict, cluster_data

if __name__=='__main__':
    import argparse, time
    parser = argparse.ArgumentParser(description='''Perform data analysis for Autodock dlg file.''')
    parser.add_argument('-i', help='the input dlg file.')
    parser.add_argument('-p', action="store_true", help='print the summary results in dlg.')
    parser.add_argument('-o', help='the output file, coordinates generated in docking process will also be wrote.')
    parser.add_argument('-plot', action="store_true", help="plot the 'number in cluster' vs 'lowest of cluster'.")
    parser.add_argument('-recluster', nargs='*', help='recluster the result based on the input rms value. \
                                                        User should provide rmsd cutoff and a new filename. \
                                                        eg: -recluster 4.0 xxx_recluster')
    parser.add_argument('-replot', action="store_true", help="plot the 'number in cluster' \
        vs 'lowest of cluster' after recluster.")
    t1 = time.time()
    args = parser.parse_args()
    dlg =args.i
    if args.i:
        coords, cluster_data, rmsd_dict, rms = dlg_parser(dlg)
        name = os.path.split(dlg)[1][:-4]
    else:
        print('Please provide a dlg file!')
        sys.exit()
    if args.p:
        print_result(cluster_data)
    if args.o:
        write_result(cluster_data, args.o)
        name = os.path.split(dlg)[1][:-4]
        pdb = name + '_lowest_e.pdb'
        group_coordinate(coords, rmsd_dict, name, lowest=True)
        group_coordinate(coords, rmsd_dict, name)
        write_rmsd(rmsd_dict, name+'_all_energy_rmsd.txt')
        print("Successfully wrote the result into '%s'." %args.o)
        lowest = name+'_lowest.pdb'
        print('The lowest energy conformations in each cluster have been put into the pdb: %s' %lowest)
        cluster = name+'_cluster_#.pdb'
        print('The conformations in each cluster have been put into the pdb: %s' %cluster)
    if args.plot:
        plot_nmuber_in_cluster(cluster_data, name, rms)
    if args.recluster:
        rms = args.recluster[0]
        if len(args.recluster) == 1:
            name = os.path.split(dlg)[1][:-4]+'_'+rms+'.txt'
        if len(args.recluster) == 2:
            name = args.recluster[1]+'_'+rms+'.txt'
        new_rmsd_dict, new_cluster_data = recluster(coords, float(rms))
        write_result(new_cluster_data, name)
        basename = os.path.split(dlg)[1][:-4]
        pdb = basename+ '_rms_'+rms
        group_coordinate(coords, new_rmsd_dict, pdb)
        group_coordinate(coords, new_rmsd_dict, pdb, lowest=True)
        write_rmsd(new_rmsd_dict, basename+'_'+rms+'_all_energy_rmsd.txt')
        print('')
        print('Successfully recluster the result based on the rmsd of %s.' %rms)
        print("The result has been wrote into '%s'." %name)
        lowest = pdb+'.pdb'
        print('The lowest energy conformations in each cluster have been put into the pdb: %s' %lowest)
        cluster = basename+'_cluster_#.pdb'
        print('The conformations in each cluster have been put into the pdb: %s' %cluster)
    if args.replot:
        plot_nmuber_in_cluster(new_cluster_data, name, rms)
    t2 = time.time()
    print('Process finished, using: %.3f s' %(t2-t1))
